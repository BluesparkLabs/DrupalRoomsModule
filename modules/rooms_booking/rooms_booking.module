<?php
   

/**
 * @file
 * Rooms Booking brings together all the pieces required to
 * find a room and book it - including the DrupalCommerce
 * integration
 */


define ('ROOM_SIZE_FAILURE', 0);
define ('AVAILABILITY_FAILURE', 1);



function rooms_booking_availability_search_form($form, $form_state) {
  
  $form['date_range']['start_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('Check-in Date'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    '#required' => TRUE,
  );
  
  $form['date_range']['end_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('Check-out Date'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    '#required' => TRUE,
  );
  
  $form['conditions']['group_size'] = array(
    '#type' => 'select',
    '#title' => 'Group Size',
    '#options' => array(
      '1' => '1',
      '2' => '2',
      '3' => '3',
      '4' => '4',
      '5' => '5',
      '6' => '6',
    ),
    '#default_value' =>  '2',
  );
  
  $form['conditions']['rooms'] = array(
    '#type' => 'select',
    '#title' => 'Rooms',
    '#options' => array(
      '1' => '1',
      '2' => '2',
      '3' => '3',
      '4' => '4',
      '5' => '5',
      '6' => '6',
    ),
    '#default_value' =>  '1',
  );
  
  $form['actions'] = array(
    '#type' => 'container',
    '#attributes' => array('class' => array('form-actions')),
    '#weight' => 400,
  );
  
  // We add the form's #submit array to this button along with the actual submit
  // handler to preserve any submit handlers added by a form callback_wrapper.
  $submit = array();

  if (!empty($form['#submit'])) {
    $submit += $form['#submit'];
  }
  
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search for Availabiliy'),
    '#submit' => $submit + array('rooms_booking_availability_search_form_submit'),
  );
  
  // We append the validate handler to #validate in case a form callback_wrapper
  // is used to add validate handlers earlier.
  $form['#validate'][] = 'rooms_booking_availability_search_form_validate';
  
  
  return $form;

}


function rooms_booking_availability_search_form_validate(&$form, &$form_state) {
  
  $now = new DateTime();
  $date1 = new DateTime($form_state['values']['start_date']);
  $date2 = new DateTime($form_state['values']['end_date']);

  dpm($now);
  
  $diff1 = $now->diff($date1);
  if ($diff1->invert) {
    form_set_error('date_range', t('Start date must be after today'));
  }
  
  $diff = $date1->diff($date2);
  // If date1 > date2
  if ($diff->invert) {
    form_set_error('date_range', t('End date must be after start date'));
  }
}


function rooms_booking_availability_search_form_submit(&$form, &$form_state) {
  
  $start_date = new DateTime($form_state['values']['start_date']);
  $end_date = new DateTime($form_state['values']['end_date']);
  $end_date->sub(new DateInterval('P1D'));
  dpm($end_date);
  
  $group_size = $form_state['values']['group_size'];
  
  $units = $form_state['values']['rooms'];
  
  $agent = new AvailabilityAgent();
  
  $units = $agent->checkAvailability($start_date, $end_date, $group_size, $units);
  
  drupal_set_message('helo');
  dpm($units);
  //dpm($form_state); 
}

  


/**
 * Implementation of hook_commerce_product_type_info()
 */
function _rooms_booking_product_type_fields() {
	
	$field_data = array (
		'rooms_booking_dates' => array (
			'field_name' => 'rooms_booking_dates',
			'label' => t('Booking Dates'),
			'cardinality'  => 1,
			'type'         => 'date',
			'module' => 'date',
			'active' => '1',
			'locked' => '1',
			'settings' => array(
			  'repeat' => 0,
			  'todate' => 'required',
			  'granularity' => array(
			    'year' => 'year',
			    'month' => 'month',
			    'day' => 'day',
			  ),
			  'tz_handling' => 'none',
			  'timezone_db' => '',
			),
		),
	  'rooms_booking_dates_instance' => array (
			'field_name' => 'rooms_booking_dates',
			'label' => t('Booking Dates'),
			'entity_type' => 'commerce_product',
			'bundle' => 'rooms_booking',
			'required' => FALSE,
			'widget' => array(
			  'type' => 'date_popup',
			  'module' => 'date',
			  'settings' => array (
			    'default_value' => 'now',
			    'default_format' => 'medium',
			  ),
			),  
		),	
		'rooms_booked_unit_id' => array (
			'field_name' => 'rooms_booked_unit_id',
			'label' => t('Booked Unit ID'),
			'cardinality' => 1,
			'type' => 'number_integer',
			'module' => 'number',
			'active' => 1,
			'locked' => 1,
		),	
		'rooms_booked_unit_id_instance' => array (
			'field_name' => 'rooms_booked_unit_id',
			'label' => t('Booked Unit ID'),
			'entity_type' => 'commerce_product',
			'bundle' => 'rooms_booking',
			'required' => true,
			'widget' => array (
        'type' => 'text_textfield',
        'settings' => array(
					'size' => 8,
          'max_length' => 10,
				),				
			),
		)
	);

  return $field_data;
}


/**
 * An AvailabilityAgent provides access to the availability functionality of DrupalRooms and
 * lets you query for availability and get pricing information
 */
class AvailabilityAgent {
  
  // The states to consider valid for an availability search
  public $valid_states;
  
  public function __construct($valid_states = array(AVAILABLE)) {
  }
  
  /**
   * Given a date range and some condition determine which rooms are available
   *
   * @param $start_date
   * The starting date for the search
   *
   * @param $end_date
   * The end date for the search
   *
   * @param $group_size
   * How many people we need to accommodate
   *
   * @param $rooms
   * In how many booking units can we accommodate the people
   *
   * @return
   * A list of valid rooms or a message as to what caused failure
   */
  public function checkAvailability ($start_date, $end_date, $group_size, $booking_units) {
    
    $units = array();

    // Determine the types of rooms that quality - the sleeping potential of the sum
    // of the rooms should satisfy the group size
    
    // If BUs = 1 then we want rooms that can sleep as big as the group size
    if ($booking_units == 1) {
      $query = new EntityFieldQuery();
      $result = $query
        ->entityCondition('entity_type', 'rooms_unit')
        ->propertyCondition('sleeps', $group_size, '>=')
        ->execute();
      
      if (count($result) == 0) {
        return ROOM_SIZE_FAILURE;
      } else {
        dpm($result['rooms_unit']);
        foreach ($result['rooms_unit'] as $unit) {
          // Get a calendar and check availability
          $rc = new UnitCalendar($unit->unit_id);
          if ($rc->stateAvailability($start_date, $end_date, array(AVAILABLE))) {
            $units[] = $unit;
          }
        }
      }
      
      // Choose all the rooms that are as big as the group_size
    }
    
    // If BUs > 1 then we want the sum of rooms to hold the group size
    
    return $units;
  }
}