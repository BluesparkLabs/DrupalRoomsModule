<?php

/**
 * @file
 * Manages availability for Rooms and displaying dates on the jquery FullCalendar
 * plugin
 */


/**
 * The default path to the FullCalendar plugin.
 */
define('FULLCALENDAR_PATH', 'sites/all/libraries/fullcalendar');

/**
 * The minimum supported version of the FullCalendar plugin.
 */
define('FULLCALENDAR_MIN_PLUGIN_VERSION', '1.4.10');


/**
 * Implements hook_library().
 */
function rooms_availability_library() {
  $libraries['rooms_fullcalendar'] = array(
    'title' => 'Rooms FullCalendar',
    'website' => 'http://arshaw.com/fullcalendar',
    'version' => FULLCALENDAR_MIN_PLUGIN_VERSION,
    'js' => array(
      rooms_availability_fullcalendar_get_js_path() => array(),
      variable_get('rooms_fullcalendar_path', FULLCALENDAR_PATH) . '/gcal.js' => array(),
    ),
    'css' => array(
      variable_get('rooms_fullcalendar_path', FULLCALENDAR_PATH) . '/fullcalendar.css' => array(
        'type' => 'file',
        'media' => 'screen',
      ),
      drupal_get_path('module', 'rooms_availability') . '/css/fullcalendar.theme.css' => array(
        'type' => 'file',
        'media' => 'screen',
      ),
    ),
    'dependencies' => array(
      array('system', 'ui.draggable'),
      array('system', 'ui.droppable'),
      array('system', 'ui.resizable'),
      array('system', 'effects.highlight'),
    ),
  );
  return $libraries;
}


/**
 * Implements hook_permission().
 */
function rooms_availability_permission() {
  $permissions = array(
    'manage room availablity' => array(
      'title' => t('manage rooms availability'),
      'description' => t('Allows users to manage availability settings for Rooms'),
      'restrict access' => TRUE,
    ),
  );
  return $permissions;
}


/**
 * Implements hook_menu().
 */
function rooms_availability_menu() {
  $items  =  array();
  
  $items['admin/rooms/rooms/room/%room/availability'] = array(
    'title' => 'Room Availability',
    'page callback' =>  'rooms_availability_page',
    'page arguments' => array(4),
    'access callback' => 'rooms_availability_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => '20',
  );
  
  $items['admin/rooms/rooms/room/ajax/%room/%action/%year/%month'] = array(
    'title' =>  'Availability Event',
    'page callback' => 'rooms_availability_event',
    'page arguments' => array(5,6,7,8),
    'access callback' => 'rooms_availability_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  $items['admin/rooms/rooms/room/ajax/test'] = array(
    'title' =>  'Availability Event Test',
    'page callback' => 'rooms_availability_event_test',
    'access arguments' => array('manage rooms availability'),
    'type' => MENU_CALLBACK,
  );
  
  $items['admin/rooms/calendartest'] = array(
    'title' => 'Calendar Tests',
    'page callback' => 'calendar_test',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  return $items;
}


function room_load($room_id){
  $room = rooms_room_load($room_id);
  return $room;
}


/**
 * Room availability access callback
 * @todo check unauthorised access for calendar js
 */ 
function rooms_availability_access($rooms_room) {
  if (user_access('manage room availability')) {
    return TRUE;
  }
  return 'FALSE';
}


/**
 * Callback for admin/rooms/rooms/room/%room/availability - builds availability
 * page by adding calendar and pulling events from availability table.
 * 
 */
function rooms_availability_page(RoomsRoom $rooms_room) {
  drupal_add_library('rooms_availability', 'rooms_fullcalendar');
  drupal_add_js(drupal_get_path('module', 'rooms_availability') . '/js/rooms_availability.js');
  drupal_add_js(array('roomId' => $rooms_room->room_id), 'setting');
  $output = theme('rooms_availability', array('name'=>$rooms_room->name, 'type'=>$rooms_room->type, 'update_form'=>drupal_get_form('update_calendar_form')));
  return $output;  
}


function update_calendar_form($form, &$form_state) {
  
  $form['date_range']['start_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('Start Date'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    '#required' => TRUE,
  );
  
  $form['date_range']['end_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('End Date'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    '#required' => TRUE,
  );
  
  
  $form['room_state'] = array(
    '#type' => 'select',
    '#title' => t('Room State'),
    '#options' => array(
      '0' => 'Available',
      '1' => 'Unavailable',
      '2' => 'Available on Request'
    ),
    '#description' => t('Choose what state to put the room in for the dates chosen above'),
  );
  
  $form['actions'] = array(
    '#type' => 'container',
    '#attributes' => array('class' => array('form-actions')),
    '#weight' => 400,
  );
  
  // We add the form's #submit array to this button along with the actual submit
  // handler to preserve any submit handlers added by a form callback_wrapper.
  $submit = array();

  if (!empty($form['#submit'])) {
    $submit += $form['#submit'];
  }
  
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update Room Availability'),
    '#submit' => $submit + array('update_calendar_form_submit'),
  );
  
  return $form;
}


function update_calendar_form_submit(&$form, &$form_state) {
  
}

/** 
 * Callback Test for json
 */
function rooms_availability_event_test() {
 
  $year = 2011;
  $month = 8;
 
  $rc = new RoomCalendar(1,0); 
  //$rc->updateCalendar($events);
  $events = $rc->getEvents(new DateTime('2010-02-01'), new DateTime('2011-12-31'));
  $json_events  = array();
  
  foreach ($events as $event) {
    $json_events[] = $event->formatJson();
  }
    
  dpm($json_events);

 
	echo  drupal_json_encode($json_events);
  
  //return $result;
}

 

/**
 * Implement rooms_availability_theme().
 */
function rooms_availability_theme() {
  return array(
    'rooms_availability' => array(
      'variables' => array('variable1', 'variable2'),
      'template' => 'rooms_availability'
    )
  );
}


/**
 * Returns the path to the FullCalendar plugin.
 */
function rooms_availability_fullcalendar_get_js_path() {
  $fullcalendar_file = array('none' => 'fullcalendar.js', 'min' => 'fullcalendar.min.js');
  return variable_get('rooms_fullcalendar_path', FULLCALENDAR_PATH) . '/' . $fullcalendar_file[variable_get('rooms_fullcalendar_compression_type', 'min')];
}



function calendar_test(){

  $output = '';
  $room = rooms_room_load(1);
  
  $start_date = new DateTime;
  $start_date->setDate(2011,2,1);

  $end_date = new DateTime;
  $end_date->setDate(2011,2,7);
  
  $start_date1 = new DateTime;
  $start_date1->setDate(2013,8,8);
  
  $end_date1 = new DateTime;
  $end_date1->setDate(2011,8,16);
  

  $start_date2 = new DateTime;
  $start_date2->setDate(2011,8,17);
  
  $end_date2 = new DateTime;
  $end_date2->setDate(2011,8,26);

    
  $event = new BookingEvent(1, 5, $start_date, $end_date);
  $event1 = new BookingEvent(1, 6, $start_date1, $end_date1);
  $event2 = new BookingEvent(1, 7, $start_date2, $end_date2);

  $events = array($event);
  
  $rc = new RoomCalendar(1,0);
  
  //$rc->updateCalendar($events);
  
  $rc->getEvents(new DateTime('2010-02-01'), new DateTime('2011-12-31'));
  //dpm($rc);

  //$event1 = new BookingEvent (1, 2,$start_date1, $end_date1 );
  //dpm($event);
  //dpm($event1);
  //$events = array($event, $event1);
  

  return $output;
}



/**
 * Handles quering and updating the availability information
 * relative to a single Room.
 */
class RoomCalendar {

  // The room the Calendar is relevant to  
  protected $room_id;
  
  // The default state for the room if it has no specific booking
  protected $default_state;
  
  
  public function __construct($room_id, $default_state){
    $this->room_id = $room_id;
    $this->default_state = $default_state;
  }
  
  
  /**
   * Given an array of events removes events from the calendar
   *
   * @param $events
   *    The events to remove from the database - an array of Booking Events
   *
   * @return
   *   The array of ids of events that were found and removed
   */
  public function removeEvents($events) {}
  
  
  /**
   * Given a date range tries to determine whether room is available for booking
   */
  public function checkAvailability(DateTime $start_date, DateTime $end_date) {}
  
  
  /**
   * Given a date range returns an array of BookingEvents
   */
  public function getEvents(DateTime $start_date, DateTime $end_date) {
    
    // Get the raw day results
    $results = $this->getRawDayData($start_date, $end_date);
    $events = array();
    foreach ($results[$this->room_id] as $year=>$months){
      $eod = rooms_end_of_month_dates($year);
      foreach ($months as $mid=>$month) {
        // The event array gives us the start days for each event within a month
        $start_days = array_keys($month['evented']);
        $i = 0;
        foreach ($month['evented'] as $start_day => $id) {
          $start_day = str_replace('d','', $start_day);
          // We need to figure out the end day of an event which is either a day before the start
          // day of th next event or the last day of the month.
          $end_day = isset($start_days[$i + 1]) ? (str_replace('d','',$start_days[$i+1])) -1 : -1;
          $end_day = ($end_day==-1) ? $eod[$mid] : $end_day;
          // Create a booking event
          $event = new BookingEvent($this->room_id,
                                    $id,
                                    new DateTime("$year-$mid-$start_day"),
                                    new DateTime("$year-$mid-$end_day"));
          $events[] = $event;
          $i++;
          
        }    
      }
    }
    return $events;
  }
  
  /**
   * Given a date range it returns all events within that range - we actually ignore
   * the exact start and end date return the whole month.
   */
  public function getRawDayData(DateTime $start_date, DateTime $end_date) {
    
    $start_year = $start_date->format('Y');
    $start_month =  $start_date->format('n');
    
    $end_year = $end_date->format('Y');
    $end_month = $end_date->format('n');
    
    $results = array();
    
    // Start by doing a query to the db to get any info stored there
    
    // If search across the same year do a single query
    if ($start_year == $end_year) {
      $query = db_select('rooms_availability', 'a');
      $query->fields('a');
      $query->condition('a.rooms_room_id', $this->room_id);
      $query->condition('a.year', $start_year);
      $query->condition('a.month', $start_month, '>=');
      $query->condition('a.month', $end_month, '<=');
      $months = $query->execute()->fetchAll(PDO::FETCH_ASSOC);   
      if (count($months) > 0) {
        foreach ($months as $month) {
          $m = $month['month'];
          $y = $month['year'];
          $id = $month['rooms_room_id'];
          unset($month['month']);
          unset($month['year']);
          unset($month['rooms_room_id']);
          $results[$id][$y][$m]['days'] = $month;
        }
      }
    }
    // For multiple years do a query for each year
    else {
      for ($j = $start_year; $j<=$end_year; $j++) {
        $query = db_select('rooms_availability', 'a');
        $query->fields('a');
        $query->condition('a.rooms_room_id', $this->room_id);
        $query->condition('a.year', $j);
        if ($j == $start_year) {
          $query->condition('a.month', $start_month, '>=');
        }
        elseif ($j == $end_year) {
          $query->condition('a.month', $end_month, '<=');
        }
        $months = $query->execute()->fetchAll(PDO::FETCH_ASSOC);
        if (count($months) > 0) {
          foreach($months as $month) {
            $m = $month['month'];
            $y = $month['year'];
            $id = $month['rooms_room_id'];
            unset($month['month']);
            unset($month['year']);
            unset($month['rooms_room_id']);
            $results[$id][$y][$m]['days'] = $month;
          }
        }
      }
    }
    
    
    // With the results from the db in place fill in any missing months
    // with the default state for the room
    for ($j = $start_year; $j<=$end_year; $j++) {
      $eod = rooms_end_of_month_dates($j);

      // We start by setting the expected start and end months for each eyar
      if ($start_year == $end_year) {
        $expected_months = $end_month - $start_month +1;
      }
      elseif ($j == $end_year) {
        $expected_months = $end_month;
        $sm = 1;
        $em = $end_month;
      }
      elseif ($j == $start_year) {
        $expected_months = 12 - $start_month +1;
        $em = 12;
        $sm = $start_month;
      }
      else {
        $expected_months = 12;
        $sm = 1;
        $em = 12;
      }
      
      // We then check to see if the months we have already fit our expectations
      $actual_months =  isset($result[$this->room_id][$j]) ? count($results[$id][$j]) : 0;
      if ($expected_months>$actual_months) {
        // We have missing months so lets go fill them
        for ($i = $sm; $i<=$em; $i++) {
          if (!isset($results[$this->room_id][$j][$i])) {
            $last_day = $eod[$i];
            $month = $this->prepareFullMonthArray(new BookingEvent($this->room_id,
                                                                   $this->default_state,
                                                                   new DateTime("$j-$i-1"), 
                                                                   new DateTime("$j-$i-$last_day")));
            // Add the month in its rightful position
            $results[$this->room_id][$j][$i]['days'] = $month;
            // And sort months
            ksort($results[$this->room_id][$j]);
          }
        }
      }        
    }

    // With all the months in place we now need to clean results to set the right end date
    // for each month - this will save code downstream from having to worry about this
    foreach ($results[$this->room_id] as $year=>$months) {
      foreach ($months as $mid => $days) {
        // There is undoubtetly a smarter way to do this - but will leave with it for now
        if (count($days['days']) != $eod[$mid]){
          switch ($eod[$mid]) {
            case 30:
              unset($results[$this->room_id][$year][$mid]['days']['d31']);
              break;
            case 29:
              unset($results[$this->room_id][$year][$mid]['days']['d31']);
              unset($results[$this->room_id][$year][$mid]['days']['d30']);
              break;
            case 28:
              unset($results[$this->room_id][$year][$mid]['days']['d31']);
              unset($results[$this->room_id][$year][$mid]['days']['d30']);
              unset($results[$this->room_id][$year][$mid]['days']['d29']);
              break;
          }
        }
      }
    }
    
    // With the results in place we do an evented array with the start and
    // end dates of each event
    foreach ($results[$this->room_id] as $year=>$months) {
      foreach ($months as $mid => $days){
        $unique_events = array_unique($days['days']);
        $results[$this->room_id][$year][$mid]['evented'] = $unique_events;
        //$results[$this->room_id][$year][$mid]['eventedflipped'] = array_flip($results[$this->room_id][$year][$mid]['evented']);
      }
    }
    
    return $results;
  }
  
  
  /**
   * Given an array of BookingEvents the calendar is updated with regards to the
   * events that are relevant to the Room this calendar refers to
   */
  public function updateCalendar(array $events) {
    
    $monthly_events = array();

    foreach ($events as $event){
      // Make sure event refers to the room for this calendar
      if ($event->room_id == $this->room_id) {
        // If the event is in the same month span just queue to be added
        if ($event->sameMonth()) {
          $monthly_events[] = $event;
        }
        else {
          // Check if multi-year
          if ($event->sameYear()) {
            $monthly_events_tmp = array();
            $monthly_events_tmp = $event->transformToMonthlyEvents();
            $monthly_events =  array_merge($monthly_events, $monthly_events_tmp);
          } else{
            //Transform to single years and then to monthly
            $yearly_events = $event->transformToYearlyEvents();
            foreach ($yearly_events as $ye){
              $monthly_events_tmp = array();
              $monthly_events_tmp = $ye->transformToMonthlyEvents();
              $monthly_events =  array_merge($monthly_events, $monthly_events_tmp);
            }
          }
        }
      }
    }
            

    foreach($monthly_events as $event) {
      $this->addMonthEvent($event);
    }
  }

  
  /**
   * Adds an event to the calendar
   *
   * @param $event
   *   An an event of type BookingEvent 
   *
   * @return
   *   TRUE if events added, FALSE if some event failed
   */
  public function addMonthEvent($event) {
    // First check if the month exists and do an update if so
    if ($this->monthDefined($event->startMonth(), $event->startYear())) {
      //Do the update
      $partial_month_row = $this->preparePartialMonthArray($event);
      dpm($partial_month_row);
      $update = db_update('rooms_availability')
        ->condition('month', $event->startMonth())
        ->condition('year', $event->startYear())
        ->fields($partial_month_row)
        ->execute();
    }
    // Do an insert for a new month
    else {
      // Prepare the days array
      $days = $this->prepareFullMonthArray($event);      
      $month_row = array (
        'rooms_room_id' => $this->room_id,
        'year' => $event->startYear(),
        'month' => $event->startMonth(),        
      );
      $month_row = array_merge($month_row, $days);
      
      $insert = db_insert('rooms_availability')->fields($month_row);
      $insert->execute();
    }
  }
    
  
  /**
   * Given an event it prepares the entire month array for it
   * assuming no other events in the month and days where there
   * is no event get set to the default state;
   */
  protected function prepareFullMonthArray($event){
    $days = array();
    $eod = rooms_end_of_month_dates($event->startYear());
    $last_day = $eod[$event->startMonth()];

    for ($i = 1; $i<=$last_day; $i++) {
      if (($i >= $event->startDay()) && ($i <= $event->endDay())) {
        $days['d' . $i] = $event->id;
      } else {
        $days['d' . $i] = '0'; //replace with default state
      }
    }
    return $days;
  }
  
  
  /**
   * Given an event it prepares a partial array covering just the days
   * for which the event is involved
   */
  protected function preparePartialMonthArray($event){
    $days = array();
    for ($i = $event->startDay(); $i<=$event->endDay(); $i++) {
        $days['d' . $i] = $event->id;
    }
    return $days;
  }
  
  /**
   * Check if a month exists
   *
   * @return true - if the month is defined
   */
  public function monthDefined($month, $year) {
    $query = db_select('rooms_availability', 'a');
    $query->addField('a', 'rooms_room_id');
    $query->addField('a', 'year');
    $query->addField('a', 'month');
    $query->condition('a.rooms_room_id', $this->room_id);
    $query->condition('a.year', $year);
    $query->condition('a.month', $month);
    $result = $query->execute()->fetchAll(PDO::FETCH_ASSOC);
    dpm($result);
    if (count($result) > 0) {
      return TRUE;
    } 
    return FALSE;
  }
  
  
}



class BookingEvent {
  
  // The room the event is relevant to
  public $room_id;
  
  // The start date for the event
  public $start_date;
  
  // The end date for the event
  public $end_date;
  
  // The type of event
  public $id;
  
  
  public function __construct($room_id, $event_id, $start_date, $end_date) {
    $this->room_id = $room_id;
    $this->id = $event_id;
    $this->start_date = $start_date;
    $this->end_date = $end_date;
  }
  
  public function startDay() {
    return $this->start_date->format('j');
  }
  
  public function startMonth() {
    return $this->start_date->format('n');
  }
  
  public function startYear() {
    return $this->start_date->format('Y');
  }
  
  public function endDay() {
    return $this->end_date->format('j');
  }
  
  public function endMonth() {
    return $this->end_date->format('n');
  }
  
  public function endYear() {
    return $this->end_date->format('Y');
  }
  
  /**
   * Returns the months involved in the events
   */
  public function months() {
    dpm($this->diff()->m);
  }

  public function diff() {
    $interval = $this->start_date->diff($this->end_date);
    return $interval;
  }
  
  public function sameMonth() {
    if (($this->startMonth() == $this->endMonth()) && ($this->startYear() == $this->endYear())) {
      return TRUE;
    }
    return FALSE;
  }
  
  public function sameYear() {
    
    if ($this->startYear() == $this->endYear()) {
      return TRUE;
    }
    return FALSE;    
  }
  
  
  /**
   * Takes an event that spans several years and transforms it to
   * yearly events
   */
  public function transformToYearlyEvents() {
    // If same year return the event
    if ($this->sameYear()) {
      $sd = new DateTime();
      $sd->setDate($this->startYear(), $this->startMonth(), $this->startDay());
      $ed = new DateTime();
      $ed->setDate($this->endYear(), $this->endMonth(), $this->endDay());
      $be = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      return array($be);
    }
    
    // Else split into years
    $events = array();
    for ($i = $this->startYear(); $i <= $this->endYear(); $i++) {
      dpm($i);
      $sd = new DateTime();
      $ed = new DateTime();
      if ($i == $this->startYear()) {
        $sd->setDate($i, $this->startMonth(), $this->startDay());
        $ed->setDate($i, 12, 31);
        $events[$i] = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      }
      elseif ($i == $this->endYear()) {
        $sd->setDate($i, 1, 1);
        $ed->setDate($i, $this->endMonth(), $this->endDay());
        $events[$i] = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      }
      else {
        $sd->setDate($i, 1, 1);
        $ed->setDate($i, 12, 31);
        $events[$i] = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      }
    }
    
    dpm($events, 'yearly events');
    return $events;
  }
  
  /**
   * Takes a single event that spans several months and transforms it to
   * monthly events - this assumes that the event is contained within a year
   */
  public function transformToMonthlyEvents() {
    $events = array();
    //First we need to split into events in separate years
    if (!$this->sameYear()) {
      dpm('azz');
      return FALSE;
    }
    if ($this->sameMonth()) {
      $sd = new DateTime();
      $sd->setDate($this->startYear(), $this->startMonth(), $this->startDay());
      $ed = new DateTime();
      $ed->setDate($this->endYear(), $this->endMonth(), $this->endDay());
      $be = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      return array($be);      
    }
    $months = rooms_end_of_month_dates($this->startYear());

    for ($i = $this->startMonth(); $i <= $this->endMonth(); $i++) {
      $sd = new DateTime();
      $ed = new DateTime();
      if ($i == $this->startMonth()) {
        $sd->setDate($this->startYear() , $i, $this->startDay());
        $ed->setDate($this->startYear(), $i, $months[$i]);
        $events[$i] = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      }
      elseif ($i == $this->endMonth()) {
        $sd->setDate($this->startYear(), $i, 1);
        $ed->setDate($this->startYear(), $i, $this->endDay());
        $events[$i] = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      }
      else{
        $sd->setDate($this->startYear(), $i, 1);
        $ed->setDate($this->startYear(), $i, $months[$i]);
        $events[$i] = new BookingEvent($this->room_id, $this->id, $sd, $ed);
      }
    }
    return $events;
  }
  
  
  /**
   * Return event in a format amenable to FullCalendar display or generally
   * sensible json
   */
  public function formatJson(){
    $event = array(
      'id' => $this->id,
      'title' => 'Event ID: ' . $this->id . ' - Room ID: ' . $this->room_id,
      'start' => $this->startYear() . '-' . $this->startMonth() . '-' . $this->startDay(),
      'end' => $this->endYear() . '-' . $this->endMonth() . '-' . $this->endDay(),
      'color' => 'red',
    );
    
    return $event;
  }
  
}







