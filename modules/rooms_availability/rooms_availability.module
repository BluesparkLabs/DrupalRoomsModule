<?php

/**
 * @file
 * Manages availability for Bookable Units and displaying dates on the jquery FullCalendar
 * plugin
 */

/**
  * Defining some room states that will be used throughout
  * 
  */
define ('NOT_AVAILABLE', 0);
define ('AVAILABLE', 1);
define ('ON_REQUEST', 2);
define ('ANON_BOOKED', 3);

/**
 * The default path to the FullCalendar plugin.
 */
define('FULLCALENDAR_PATH', 'sites/all/libraries/fullcalendar');

/**
 * The minimum supported version of the FullCalendar plugin.
 */
define('FULLCALENDAR_MIN_PLUGIN_VERSION', '1.4.10');


/**
 * Implements hook_library().
 */
function rooms_availability_library() {
  $libraries['rooms_fullcalendar'] = array(
    'title' => 'Rooms FullCalendar',
    'website' => 'http://arshaw.com/fullcalendar',
    'version' => FULLCALENDAR_MIN_PLUGIN_VERSION,
    'js' => array(
      rooms_availability_fullcalendar_get_js_path() => array(),
      variable_get('rooms_fullcalendar_path', FULLCALENDAR_PATH) . '/gcal.js' => array(),
    ),
    'css' => array(
      variable_get('rooms_fullcalendar_path', FULLCALENDAR_PATH) . '/fullcalendar.css' => array(
        'type' => 'file',
        'media' => 'screen',
      ),
      drupal_get_path('module', 'rooms_availability') . '/css/fullcalendar.theme.css' => array(
        'type' => 'file',
        'media' => 'screen',
      ),
    ),
    'dependencies' => array(
      array('system', 'ui.draggable'),
      array('system', 'ui.droppable'),
      array('system', 'ui.resizable'),
      array('system', 'effects.highlight'),
    ),
  );
  return $libraries;
}


/**
 * Implements hook_permission().
 */
function rooms_availability_permission() {
  $permissions = array(
    'manage booking unit availablity' => array(
      'title' => t('manage booking unit availability'),
      'description' => t('Allows users to manage availability settings for Rooms'),
      'restrict access' => TRUE,
    ),
  );
  return $permissions;
}


/**
 * Implements hook_menu().
 */
function rooms_availability_menu() {
  $items  =  array();
  
  $items['admin/rooms/units/unit/%availability_unit/availability'] = array(
    'title' => 'Manage Availability',
    'page callback' =>  'rooms_availability_page',
    'page arguments' => array(4,6,7),
    'access callback' => 'rooms_availability_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => '20',
  );
  
  $items['admin/rooms/units/unit/%availability_unit/availability/json/%/%'] = array(
    'title' =>  'Availability Event',
    'page callback' => 'rooms_availability_event',
    'page arguments' => array(4,7,8,9,10,11,12),
    'access callback' => 'rooms_availability_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'weight' => '30',
  );


  
  
  return $items;
}



/**
 * Menu load for units - calls the actuall rooms_unit_load implemented in rooms_unit.module
 */
function availability_unit_load($unit_id){
  $unit = rooms_unit_load($unit_id);
  return $unit;
}


/**
 * Room availability access callback
 * @todo check unauthorised access for calendar js
 */ 
function rooms_availability_access($rooms_unit) {
  if (user_access('manage booking unit availability')) {
    return TRUE;
  }
  return 'FALSE';
}


/**
 * Callback for admin/rooms/units/unit/%unit/availability - builds availability
 * page by adding calendar and pulling events from availability table.
 * 
 */
function rooms_availability_page(RoomsUnit $rooms_unit, $year='', $month='') {
  
  // Basic check to avoid any uggliness
  $year = check_plain($year);
  $month = check_plain($month);
  
  // If year is not set then give it the current date
  $year = ($year == '') ? date('Y', time()) : $year;
  $month = ($month == '') ? date('m', time()) : $month;

  // Add all the stuff we will need to show the FullCalendar  
  drupal_add_library('rooms_availability', 'rooms_fullcalendar');
  drupal_add_js(drupal_get_path('module', 'rooms_availability') . '/js/rooms_availability.js');
  drupal_add_css(drupal_get_path('module', 'rooms_availability') . '/css/fullcalendar.theme.css');
  drupal_add_css(drupal_get_path('module', 'rooms_availability') . '/css/rooms_availability.css');
  
  // Injest settings in javascript that we will use
  drupal_add_js(array('roomID' => $rooms_unit->unit_id), 'setting');
  drupal_add_js(array('currentMonth' => $month), 'setting');
  drupal_add_js(array('currentYear' => $year), 'setting');

  // Calculate forward and back dates for our 3-month view calendar and create links
  $date1 = new DateTime("$year-$month-1");
  $date2 = new DateTime("$year-$month-1");
  $date_current = new DateTime("now");


  $forward = $date1->add(new DateInterval('P3M'));
  $forward_path = 'admin/rooms/units/unit/' . $rooms_unit->unit_id . '/availability/' . $forward->format('Y') . '/' . $forward->format('n');
  $forward_link = l(t('Forward'), $forward_path);

  $backward = $date2->sub(new DateInterval('P3M'));
  $backward_path = 'admin/rooms/units/unit/' . $rooms_unit->unit_id . '/availability/' . $backward->format('Y') . '/' . $backward->format('n');
  $backward_link = l(t('Back'), $backward_path);
  
  $current_path = 'admin/rooms/units/unit/' . $rooms_unit->unit_id . '/availability/' . $date_current->format('Y') . '/' . $date_current->format('n');
  $current_link = l(t('Current'), $current_path);

  // Send everything for theming
  $output = theme('rooms_availability', array('name' => $rooms_unit->name,
                                              'type' => $rooms_unit->type,
                                              'update_form' => drupal_get_form('update_availability_calendar_form', $rooms_unit->unit_id),
                                              'start_year' => $year,
                                              'start_month' => $month,
                                              'forward_link' => $forward_link,
                                              'backward_link' => $backward_link,
                                              'current_link' => $current_link,)
                 );

  return $output;  
}


/**
 * A basic form that allows us to update the state of the calendar
 */
function update_availability_calendar_form($form, &$form_state, $unit_id) {
  
  $form['unit_id'] = array (
    '#type' => 'hidden',
    '#value' => $unit_id,
  );
  
  $form['date_range']['start_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('Start Date'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    '#required' => TRUE,
  );
  
  $form['date_range']['end_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('End Date'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    '#required' => TRUE,
  );
  
  
  $form['unit_state'] = array(
    '#type' => 'select',
    '#title' => t('Bookable Unit State'),
    '#options' => array(
      NOT_AVAILABLE => 'Unavailable',
      AVAILABLE => 'Available',
      ON_REQUEST => 'Available on Request',
      ANON_BOOKED => 'Anonymous Booking'
    ),
    '#description' => t('Choose what state to put the unit in for the dates chosen above'),
  );
  
  $form['actions'] = array(
    '#type' => 'container',
    '#attributes' => array('class' => array('form-actions')),
    '#weight' => 400,
  );
  
  // We add the form's #submit array to this button along with the actual submit
  // handler to preserve any submit handlers added by a form callback_wrapper.
  $submit = array();

  if (!empty($form['#submit'])) {
    $submit += $form['#submit'];
  }
  
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update Room Availability'),
    '#submit' => $submit + array('update_availability_calendar_form_submit'),
  );
  
  // We append the validate handler to #validate in case a form callback_wrapper
  // is used to add validate handlers earlier.
  $form['#validate'][] = 'update_availability_calendar_form_validate';
  
  
  return $form;
}


function update_availability_calendar_form_validate(&$form, &$form_state) {
  // Check date validity
  $date1 = new DateTime($form_state['values']['start_date']);
  $date2 = new DateTime($form_state['values']['end_date']);
  $diff = $date1->diff($date2);
  // If date1 > date2
  if ($diff->invert) {
    form_set_error('date_range', t('End date must be after start date'));
  }
}


/**
 *@todo Need to figure out what to do when we cancel an existing booking
 */

function update_availability_calendar_form_submit(&$form, &$form_state) {
  
  $start_date = new DateTime($form_state['values']['start_date']);
  $end_date = new DateTime($form_state['values']['end_date']);
  $event_id = $form_state['values']['unit_state'];
  
  $unit_id = $form_state['values']['unit_id'];
  
  // Create a new Booking Event
  $be = new BookingEvent($unit_id, $event_id, $start_date, $end_date);
  $events = array($be);
  $rc = new UnitCalendar($unit_id);
  $rc->updateCalendar($events);  
}



/** 
 * Creates the necessary json for the date range provided - needs at least start year and month at which point it will
 * return the entire month.
 */
function rooms_availability_event($unit, $start_year = '', $start_month = '', $start_day = '', $end_year = '', $end_month = '', $end_day = '') {

  $start_year = (int)$start_year;
  $start_month = (int)$start_month;
  $start_day = (int)$start_day;
  
  $end_year = (int)$end_year;
  $end_month = (int)$end_month;
  $end_day = (int)$end_day;
  
  $eom = rooms_end_of_month_dates($start_year);
    
  if (($start_year == 0) || ($start_month == 0)) {
    echo drupal_json_encode('missing basic info');
    return;
  } elseif ($start_day == 0) {
    $start_date = new DateTime("$start_year-$start_month-1");
    $end_day = $eom[$start_month];
    $end_date = new DateTime("$start_year-$start_month-$end_day");
  } elseif ($start_day != 0 && $end_year == 0) {
    $start_date = new DateTime("$start_year-$start_month-$start_day");
    $end_date = new DateTime("$start_year-$start_month-15");
    $end_date->add(new DateInterval('P1M'));
    $end_year = $end_date->format('Y');
    $end_month = $end_date->format('n');
    $end_day = $eom[$end_date->format('n')];
    $end_date = new DateTime("$end_year-$end_month-$end_day");
  }
  else{
    $start_date = new DateTime("$start_year-$start_month-$start_day");
    $end_date = new DateTime("$end_year-$end_month-$end_day");    
  }

  $rc = new UnitCalendar($unit->unit_id, $unit->default_state);
  
  $events = $rc->getEvents($start_date, $end_date);
  $json_events  = array();
  
  foreach ($events as $event) {
    $json_events[] = $event->formatJson();
  }
    
 
	echo  drupal_json_encode($json_events);
  
}

 

/**
 * Implement rooms_availability_theme().
 */
function rooms_availability_theme() {
  return array(
    'rooms_availability' => array(
      'template' => 'rooms_availability'
    )
  );
}


/**
 * Returns the path to the FullCalendar plugin.
 */
function rooms_availability_fullcalendar_get_js_path() {
  $fullcalendar_file = array('none' => 'fullcalendar.js', 'min' => 'fullcalendar.min.js');
  return variable_get('rooms_fullcalendar_path', FULLCALENDAR_PATH) . '/' . $fullcalendar_file[variable_get('rooms_fullcalendar_compression_type', 'min')];
}







/**
 * Handles quering and updating the availability information
 * relative to a single bookable unit.
 */
class UnitCalendar {

  // The bookable unit the Calendar is relevant to  
  protected $unit_id;
  
  // The default state for the room if it has no specific booking
  protected $default_state;
  
  
  public function __construct($unit_id){
    $this->unit_id = $unit_id;
    // Load the booking unit
    $unit = rooms_unit_load($unit_id);
    $this->default_state = $unit->default_state;
  }
  
  
  /**
   * Given an array of events removes events from the calendar - keeping this for reference
   * but the fact is that we may never need this - remove an event is simply changing the state
   * of the calendar.
   *
   * @param $events
   *    The events to remove from the database - an array of Booking Events
   *
   * @return
   *   The array of ids of events that were found and removed
   */
  public function removeEvents($events) {}
  
  
  /**
   * Given a date range and a set of states tries to determine whether a bookable unit is available for booking.
   *
   * @param $start_date
   * The starting date for the search
   *
   * @param $end_date
   * The end date for the search
   *
   * @param $states
   * The states we are interested in
   *
   * @return
   * Returns true if the date range provided does not have states other than the ones we are
   * interested in
   */
  public function stateAvailability(DateTime $start_date, DateTime $end_date, $states = array()) {
    
    $valid = true;
    
    //get all events in the date range
    $events = $this->getEvents($start_date, $end_date);
    foreach ($events as $event) {
      if (!in_array($event->id, $states)) {
        $valid = false;
      }
    }
    
    return $valid;
  }
  
  
  /**
   * Given a date range returns an array of BookingEvents. The heavy lifting really takes place in
   * the getRawDayData function - here we are simply acting as a factory for event objects
   *
   * @param $start_date
   * The starting date
   *
   * @param $end_date
   * The end date of our range
   *
   * @returns
   * An array of BookingEvent objects
   */
  public function getEvents(DateTime $start_date, DateTime $end_date) {

    
    $start_day = $start_date->format('j');
    $end_day = $end_date->format('j');
    
    
    // Get the raw day results
    $results = $this->getRawDayData($start_date, $end_date);
    $events = array();
    foreach ($results[$this->unit_id] as $year=>$months){
      $eod = rooms_end_of_month_dates($year);
      foreach ($months as $mid=>$month) {
        // The event array gives us the start days for each event within a month
        $start_days = array_keys($month['states']);
        foreach ($month['states'] as $state) {
          // Create a booking event 
          $start = $state['start_day'];
          $end= $state['end_day'];
          $sd = new DateTime("$year-$mid-$start");
          $ed = new DateTime("$year-$mid-$end");
                    
          $event = new BookingEvent($this->unit_id,
                                    $state['state'],
                                    $sd,
                                    $ed);
          $events[] = $event;
        }    
      }
    }
    return $events;
  }
  
  
  /**
   * Given a date range it returns all data within that range including the start and
   * end dates of states. The MySQL queries are kept simple and then the data is cleared up
   * 
   * @param $start_date
   * The starting date
   *
   * @param $end_date
   * The end date of our range
   *
   * @return
   * An array of the structure data[unitid][year][month][days][d1]..[d31]
   * as wekk as data[unitid][year][month][unique_states]
   */
  public function getRawDayData(DateTime $start_date, DateTime $end_date) {
    
    // Create a dummy BookingEvent to represent the range we are searching over
    // This gives us access to handy functions that BookingEvents have
    $s = new BookingEvent($this->unit_id, 0, $start_date, $end_date);    
    
    $results = array();
    
    // Start by doing a query to the db to get any info stored there
    
    // If search across the same year do a single query
    if ($s->sameYear()) {
      $query = db_select('rooms_availability', 'a');
      $query->fields('a');
      $query->condition('a.unit_id', $this->unit_id);
      $query->condition('a.year', $s->startYear());
      $query->condition('a.month', $s->startMonth(), '>=');
      $query->condition('a.month', $s->endMonth(), '<=');
      $months = $query->execute()->fetchAll(PDO::FETCH_ASSOC);   
      if (count($months) > 0) {
        foreach ($months as $month) {
          $m = $month['month'];
          $y = $month['year'];
          $id = $month['unit_id'];
          // Remove the three first rows and just keep the days
          unset($month['month']);
          unset($month['year']);
          unset($month['unit_id']);
          $results[$id][$y][$m]['days'] = $month;
        }
      }
    }
    // For multiple years do a query for each year
    else {
      for ($j = $s->startYear(); $j <= $s->endYear(); $j++) {
        $query = db_select('rooms_availability', 'a');
        $query->fields('a');
        $query->condition('a.unit_id', $this->unit_id);
        $query->condition('a.year', $j);
        if ($j == $s->startYear()) {
          $query->condition('a.month', $s->startMonth(), '>=');
        }
        elseif ($j == $s->endYear()) {
          $query->condition('a.month', $s->endMonth(), '<=');
        }
        $months = $query->execute()->fetchAll(PDO::FETCH_ASSOC);
        if (count($months) > 0) {
          foreach($months as $month) {
            $m = $month['month'];
            $y = $month['year'];
            $id = $month['unit_id'];
            unset($month['month']);
            unset($month['year']);
            unset($month['unit_id']);
            $results[$id][$y][$m]['days'] = $month;
          }
        }
      }
    }
    
    
    // With the results from the db in place fill in any missing months
    // with the default state for the unit
    for ($j = $s->startYear(); $j <= $s->endYear(); $j++) {
      $eod = rooms_end_of_month_dates($j);

      // We start by setting the expected start and end months for each year
      if ($s->sameYear()) {
        $expected_months = $s->endMonth() - $s->startMonth() +1;
        $sm = $s->startMonth();
        $em = $s->endMonth();
      }
      elseif ($j == $s->endYear()) {
        $expected_months = $s->endMonth();
        $sm = 1;
        $em = $s->endMonth();
      }
      elseif ($j == $s->startYear()) {
        $expected_months = 12 - $s->startMonth() +1;
        $em = 12;
        $sm = $s->startMonth();
      }
      else {
        $expected_months = 12;
        $sm = 1;
        $em = 12;
      }
      
      // We then check to see if the months we have already fit our expectations
      $actual_months =  isset($result[$this->unit_id][$j]) ? count($results[$id][$j]) : 0;
      if ($expected_months>$actual_months) {
        // We have missing months so lets go fill them
        for ($i = $sm; $i<=$em; $i++) {
          if (!isset($results[$this->unit_id][$j][$i])) {
            $last_day = $eod[$i];
            $month = $this->prepareFullMonthArray(new BookingEvent($this->unit_id,
                                                                   $this->default_state,
                                                                   new DateTime("$j-$i-1"), 
                                                                   new DateTime("$j-$i-$last_day")));
            // Add the month in its rightful position
            $results[$this->unit_id][$j][$i]['days'] = $month;
            // And sort months
            ksort($results[$this->unit_id][$j]);
          }
        }
      }        
    }

    // With all the months in place we now need to clean results to set the right start and end date
    // for each month - this will save code downstream from having to worry about it
    foreach ($results[$this->unit_id] as $year=>$months) {
      foreach ($months as $mid => $days) {
        // There is undoubtetly a smarter way to do this - but will live with this for now
        if (count($days['days']) != $eod[$mid]){
          switch ($eod[$mid]) {
            case 30:
              unset($results[$this->unit_id][$year][$mid]['days']['d31']);
              break;
            case 29:
              unset($results[$this->unit_id][$year][$mid]['days']['d31']);
              unset($results[$this->unit_id][$year][$mid]['days']['d30']);
              break;
            case 28:
              unset($results[$this->unit_id][$year][$mid]['days']['d31']);
              unset($results[$this->unit_id][$year][$mid]['days']['d30']);
              unset($results[$this->unit_id][$year][$mid]['days']['d29']);
              break;
          }
        }
        if (($year == $s->startYear()) && ($mid == $s->startMonth())) {
          // We know we have the entire months over the range so we just unset all the dates
          // from the start of the month to the actual start day
          for ($i = 1; $i < $s->startDay(); $i++) {
            unset($results[$this->unit_id][$year][$mid]['days']['d'.$i]);
          }
        }
        if (($year == $s->endYear()) && ($mid == $s->endMonth())){
          // and from the end of the month back to the actual end day
          for ($i = $s->endDay()+1; $i <= $eod[$mid]; $i++) {
            unset($results[$this->unit_id][$year][$mid]['days']['d'.$i]);
          }
        }

      }
    }
        
    // With the results in place we do a states array with the start and
    // end dates of each event
    foreach ($results[$this->unit_id] as $year=>$months) {
      foreach ($months as $mid => $days){
        // The number of days in the month we are interested in eventing
        $j = count($days);
        // The start date (in case we are not starting from the first day of the month)
        $i = substr(key($days['days']), 1);
        $start_day = $i;
        $end_day = null;
        $unique_states = array();
        $old_state = $days['days']['d'.$i];
        $state = $days['days']['d'.$i];
        while ($j <= count($days['days']) )
        {          
          $state = $days['days']['d'.$i];
          if ($state != $old_state){
            $unique_states[] = array('state' => $old_state,
                                               'start_day' => $start_day,
                                               'end_day' => $i-1);
            $end_day = $i - 1;
            $start_day = $i;
            $old_state = $state;
          }
          $i++;
          $j++;
        }
        // Get the last event in
        $unique_states[] = array('state' => $state,
                                   'start_day' => isset($end_day) ? $end_day+1 : $start_day,
                                   'end_day' => $i-1);
        $results[$this->unit_id][$year][$mid]['states'] = $unique_states;
      }
    }
    
    return $results;
  }
  
  
  /**
   * Given an array of BookingEvents the calendar is updated with regards to the
   * events that are relevant to the Unit this calendar refers to
   */
  public function updateCalendar(array $events) {
    
    $monthly_events = array();

    foreach ($events as $event){
      // Make sure event refers to the unit for this calendar
      if ($event->unit_id == $this->unit_id) {
        // If the event is in the same month span just queue to be added
        if ($event->sameMonth()) {
          $monthly_events[] = $event;
        }
        else {
          // Check if multi-year - if not just create monthly events
          if ($event->sameYear()) {
            $monthly_events_tmp = array();
            $monthly_events_tmp = $event->transformToMonthlyEvents();
            $monthly_events =  array_merge($monthly_events, $monthly_events_tmp);
          } else{
            // else transform to single years and then to monthly
            $yearly_events = $event->transformToYearlyEvents();
            foreach ($yearly_events as $ye){
              $monthly_events_tmp = array();
              $monthly_events_tmp = $ye->transformToMonthlyEvents();
              $monthly_events =  array_merge($monthly_events, $monthly_events_tmp);
            }
          }
        }
      }
    }
            

    foreach($monthly_events as $event) {
      $this->addMonthEvent($event);
    }
  }

  
  /**
   * Adds an event to the calendar
   *
   * @param $event
   *   An an event of type BookingEvent 
   *
   * @return
   *   TRUE if events added, FALSE if some event failed
   */
  public function addMonthEvent($event) {
    // First check if the month exists and do an update if so
    if ($this->monthDefined($event->startMonth(), $event->startYear())) {
      //Do the update
      $partial_month_row = $this->preparePartialMonthArray($event);
      $update = db_update('rooms_availability')
        ->condition('unit_id', $this->unit_id)
        ->condition('month', $event->startMonth())
        ->condition('year', $event->startYear())
        ->fields($partial_month_row)
        ->execute();
    }
    // Do an insert for a new month
    else {
      // Prepare the days array
      $days = $this->prepareFullMonthArray($event);      
      $month_row = array (
        'unit_id' => $this->unit_id,
        'year' => $event->startYear(),
        'month' => $event->startMonth(),        
      );
      $month_row = array_merge($month_row, $days);
      
      $insert = db_insert('rooms_availability')->fields($month_row);
      $insert->execute();
    }
  }
    
  
  /**
   * Given an event it prepares the entire month array for it
   * assuming no other events in the month and days where there
   * is no event get set to the default state;
   */
  protected function prepareFullMonthArray($event){
    $days = array();
    $eod = rooms_end_of_month_dates($event->startYear());
    $last_day = $eod[$event->startMonth()];

    for ($i = 1; $i<=$last_day; $i++) {
      if (($i >= $event->startDay()) && ($i <= $event->endDay())) {
        $days['d' . $i] = $event->id;
      } else {
        $days['d' . $i] = $this->default_state; //replace with default state
      }
    }
    return $days;
  }
  
  
  /**
   * Given an event it prepares a partial array covering just the days
   * for which the event is involved
   */
  protected function preparePartialMonthArray($event){
    $days = array();
    for ($i = $event->startDay(); $i<=$event->endDay(); $i++) {
        $days['d' . $i] = $event->id;
    }
    return $days;
  }
  
  /**
   * Check if a month exists
   *
   * @return true - if the month is defined
   */
  public function monthDefined($month, $year) {
    $query = db_select('rooms_availability', 'a');
    $query->addField('a', 'unit_id');
    $query->addField('a', 'year');
    $query->addField('a', 'month');
    $query->condition('a.unit_id', $this->unit_id);
    $query->condition('a.year', $year);
    $query->condition('a.month', $month);
    $result = $query->execute()->fetchAll(PDO::FETCH_ASSOC);
    if (count($result) > 0) {
      return TRUE;
    } 
    return FALSE;
  }
  
  
}



class BookingEvent {
  
  // The room the event is relevant to
  public $unit_id;
  
  // The start date for the event
  public $start_date;
  
  // The end date for the event
  public $end_date;
  
  // The type of event
  public $id;
  
  
  public function __construct($unit_id, $event_id, $start_date, $end_date) {
    $this->unit_id = $unit_id;
    $this->id = $event_id;
    $this->start_date = $start_date;
    $this->end_date = $end_date;
  }
  
  public function startDay($format = 'j') {
    return $this->start_date->format($format);
  }
  
  public function startMonth($format = 'n') {
    return $this->start_date->format($format);
  }
  
  public function startYear($format = 'Y') {
    return $this->start_date->format($format);
  }
  
  public function endDay($format = 'j') {
    return $this->end_date->format($format);
  }
  
  public function endMonth($format = 'n') {
    return $this->end_date->format($format);
  }
  
  public function endYear($format = 'Y') {
    return $this->end_date->format($format);
  }
  
  /**
   * Returns the months involved in the events
   */
  public function months() {
    dpm($this->diff()->m);
  }

  public function diff() {
    $interval = $this->start_date->diff($this->end_date);
    return $interval;
  }
  
  public function sameMonth() {
    if (($this->startMonth() == $this->endMonth()) && ($this->startYear() == $this->endYear())) {
      return TRUE;
    }
    return FALSE;
  }
  
  public function sameYear() {
    
    if ($this->startYear() == $this->endYear()) {
      return TRUE;
    }
    return FALSE;    
  }
  
  
  /**
   * Takes an event that spans several years and transforms it to
   * yearly events
   */
  public function transformToYearlyEvents() {
    // If same year return the event
    if ($this->sameYear()) {
      $sd = new DateTime();
      $sd->setDate($this->startYear(), $this->startMonth(), $this->startDay());
      $ed = new DateTime();
      $ed->setDate($this->endYear(), $this->endMonth(), $this->endDay());
      $be = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      return array($be);
    }
    
    // Else split into years
    $events = array();
    for ($i = $this->startYear(); $i <= $this->endYear(); $i++) {
      $sd = new DateTime();
      $ed = new DateTime();
      if ($i == $this->startYear()) {
        $sd->setDate($i, $this->startMonth(), $this->startDay());
        $ed->setDate($i, 12, 31);
        $events[$i] = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      }
      elseif ($i == $this->endYear()) {
        $sd->setDate($i, 1, 1);
        $ed->setDate($i, $this->endMonth(), $this->endDay());
        $events[$i] = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      }
      else {
        $sd->setDate($i, 1, 1);
        $ed->setDate($i, 12, 31);
        $events[$i] = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      }
    }
    
    return $events;
  }
  
  /**
   * Takes a single event that spans several months and transforms it to
   * monthly events - this assumes that the event is contained within a year
   */
  public function transformToMonthlyEvents() {
    $events = array();
    //First we need to split into events in separate years
    if (!$this->sameYear()) {
      return FALSE;
    }
    if ($this->sameMonth()) {
      $sd = new DateTime();
      $sd->setDate($this->startYear(), $this->startMonth(), $this->startDay());
      $ed = new DateTime();
      $ed->setDate($this->endYear(), $this->endMonth(), $this->endDay());
      $be = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      return array($be);      
    }
    $months = rooms_end_of_month_dates($this->startYear());

    for ($i = $this->startMonth(); $i <= $this->endMonth(); $i++) {
      $sd = new DateTime();
      $ed = new DateTime();
      if ($i == $this->startMonth()) {
        $sd->setDate($this->startYear() , $i, $this->startDay());
        $ed->setDate($this->startYear(), $i, $months[$i]);
        $events[$i] = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      }
      elseif ($i == $this->endMonth()) {
        $sd->setDate($this->startYear(), $i, 1);
        $ed->setDate($this->startYear(), $i, $this->endDay());
        $events[$i] = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      }
      else{
        $sd->setDate($this->startYear(), $i, 1);
        $ed->setDate($this->startYear(), $i, $months[$i]);
        $events[$i] = new BookingEvent($this->unit_id, $this->id, $sd, $ed);
      }
    }
    return $events;
  }
  
  
  /**
   * Return event in a format amenable to FullCalendar display or generally
   * sensible json
   */
  public function formatJson(){
    $event = array(
      'id' => $this->id,
      'title' => $this->id,
      'start' => $this->startYear() . '-' . $this->startMonth('m') . '-' . $this->startDay('d'),
      'end' => $this->endYear() . '-' . $this->endMonth('m') . '-' . $this->endDay('d'),
    );
    
    //set the color
    switch ($this->id) {
      case NOT_AVAILABLE:
        $event['color']  = 'red';
        $event['title'] = 'N/A';
        break;
      case AVAILABLE:
        $event['color'] = 'green';
        $event['title'] = 'A';
        break;
      case ON_REQUEST:
        $event['color'] = 'gray';
        $event['title'] = 'REQ';
        break;        
      case ANON_BOOKED:
        $event['color'] = '#481600';
        $event['title'] = 'A-B';
        break;        
      default:
        $event['color'] = 'blue';
        break;
    }
    
    return $event;
  }
  
}


